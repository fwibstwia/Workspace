Require Import List.
Require Import Arith.
Require Import ZArith.


Inductive tree : Set :=
  | Leaf : nat -> tree
  | Node : tree -> tree -> list nat -> tree.
Notation t := tree.

Section comm_eq.

Variables (A : Set) (f : A -> A -> A).

Hypothesis comm : forall x y : A, f x y = f y x.


Fixpoint tree_A (l:list A)(def:A)(tr:t) : A :=
 match tr with
 | Node t1 t2 _ => f (tree_A l def t1) (tree_A l def t2)
 | Leaf n => nth (n - 1) l def
 end.

Definition pre_list (m : t) : list nat :=
 match m with
 | Leaf n => n::nil
 | Node _ _  pre_list => pre_list
 end.

Fixpoint pre_list_compare (ell elr:list nat) : bool :=
 match ell, elr with
 | a::l', b::r' => match (nat_compare a b) with 
                   | Lt => true
                   | Gt => false
                   | Eq => (pre_list_compare l' r')
                   end
 | nil, _ => true
 | _, nil => false
 end. 

Fixpoint sort_tree (tr : t) : t :=
 match tr with
 | Node t1 t2 _ => let lt := sort_tree t1 in
                   let rt := sort_tree t2 in
                   if pre_list_compare (pre_list lt) (pre_list rt) then
                      Node lt rt (0::nil ++ (pre_list lt) ++ (pre_list rt))
                   else 
                      Node rt lt (0::nil ++ (pre_list rt) ++ (pre_list lt))
 | Leaf n => Leaf n
 end.

Theorem comm_aux_valid : forall (l:list A) (def:A) (tr:t), tree_A l def (sort_tree tr) = tree_A l def tr.
Proof.
 intros.
 induction tr.
 auto.
 unfold sort_tree.
 fold sort_tree.
 destruct (pre_list_compare (pre_list (sort_tree tr1))).
 simpl.
 rewrite IHtr1.
 rewrite IHtr2.
 reflexivity.
 simpl.
 rewrite IHtr1.
 rewrite IHtr2.
 apply comm.
Qed.

Theorem comm_valid : 
  forall (l : list A) (def: A) (tr tr':t), tree_A l def (sort_tree tr) = tree_A l def (sort_tree tr') ->
              tree_A l def tr = tree_A l def tr'.
Proof.
  intros.
  rewrite <- (comm_aux_valid l def tr). 
  rewrite <- (comm_aux_valid l def tr').
  trivial.
Qed.

End comm_eq.

Ltac term_list f l v :=
  match v with
  | (f ?X1 ?X2) =>
    let l1 := term_list f l X2 in term_list f l1 X1
  | ?X1 => constr:(cons X1 l)
  end.

Ltac compute_rank l n v :=
  match l with
  | (cons ?X1 ?X2) =>
    let tl := constr:X2 in
    match constr:(X1 = v) with
    | (?X1 = ?X1) => n
    | _ => compute_rank tl (S n) v
    end
  end.

Ltac model_aux l f v :=
 match v with
 | (f ?X1 ?X2) =>
   let r1 := model_aux l f X1 with r2 := model_aux l f X2 in 
       constr:(Node r1 r2 nil)
 | ?X1 => let n := compute_rank l 1 X1 in constr:(Leaf n) 
 | _ => constr:(Leaf 1)
 end.

Ltac comm_eq A f comm_thm :=
  match goal with
  | [ |- (?X1 = ?X2 :>A) ] =>
    let l := term_list f (nil (A:=A)) X1 in
    let term1 := model_aux l f X1 
    with term2 := model_aux l f X2 in
    (change (tree_A A f l X1 term1 = tree_A A f l X1 term2);
     apply comm_valid with (1 := comm_thm); auto)
  end.
Open Scope Z_scope.
Theorem comm_test:
forall a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14 a15 a16 a17 a18 a19 a20 a21 a22 a23 a24 a25 a26 a27 a28 a29 a30 a31 a32 a33 a34 a35 a36 a37 a38 a39 a40 a41 a42 a43 a44 a45 a46 a47 a48 a49 a50 a51 a52 a53 a54 a55 a56 a57 a58 a59 a60 a61 a62 a63 a64 a65 a66 a67 a68 a69 a70 a71 a72 a73 a74 a75 a76 a77 a78 a79 a80 a81 a82 a83 a84 a85 a86 a87 a88 a89 a90 a91 a92 a93 a94 a95 a96 a97 a98 a99 : Z,(a0+a1+a2+a3+a4+a5+a6+a7+a8+a9+a10+a11+a12+a13+a14+a15+a16+a17+a18+a19+a20+a21+a22+a23+a24+a25+a26+a27+a28+a29+a30+a31+a32+a33+a34+a35+a36+a37+a38+a39+a40+a41+a42+a43+a44+a45+a46+a47+a48+a49)+(a50+a51+a52+a53+a54+a55+a56+a57+a58+a59+a60+a61+a62+a63+a64+a65+a66+a67+a68+a69+a70+a71+a72+a73+a74+a75+a76+a77+a78+a79+a80+a81+a82+a83+a84+a85+a86+a87+a88+a89+a90+a91+a92+a93+a94+a95+a96+a97+a98+a99)=(a50+a51+a52+a53+a54+a55+a56+a57+a58+a59+a60+a61+a62+a63+a64+a65+a66+a67+a68+a69+a70+a71+a72+a73+a74+a75+a76+a77+a78+a79+a80+a81+a82+a83+a84+a85+a86+a87+a88+a89+a90+a91+a92+a93+a94+a95+a96+a97+a98+a99)+(a0+a1+a2+a3+a4+a5+a6+a7+a8+a9+a10+a11+a12+a13+a14+a15+a16+a17+a18+a19+a20+a21+a22+a23+a24+a25+a26+a27+a28+a29+a30+a31+a32+a33+a34+a35+a36+a37+a38+a39+a40+a41+a42+a43+a44+a45+a46+a47+a48+a49).



Proof.
 intros.
 ring.
Qed.
